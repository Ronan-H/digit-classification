<!doctype html>

<html lang="en">
    <head>
        <!-- from bootstrap starter template -->
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <!-- custom stylesheet on top of bootstrap -->
        <link rel="stylesheet" href="static/style.css">

        <title>Digit Classifier</title>
    </head>

    <body onload="init()">
        <div class="container mt-3">
            <div class="row">
                <div class="col-md-9">
                    <h2>Digit classifier</h2>
                </div>
            </div>

            <div class="row">
                <div class="col-md-9">
                    <h4>Draw a digit below to see how the neural network classifies it</h4>
                </div>
            </div>

            <div class="row">
                <div class="col-md-9">
                    <canvas id="digit-canvas" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="row">
                <div class="col-md-9">
                    <button id="clear-button" type="button" onclick="reset()" class="btn btn-primary">Clear</button>
                </div>
            </div>

            <br />

            <div class="row">
                <div class="col-md-9">
                    <h4>Classification:</h2>
                </div>
            </div>

            <div class="row">
                <div class="col-md-9">
                    <h2 id="classification"></h2>
                </div>
            </div>

            <div class="row">
                <div class="col-md-9">
                    <h5 id="classify-time" class="font-italic"></h2>
                </div>
            </div>
        </div>

        <script>
            // adapted from https://stackoverflow.com/a/8398189
            var canvas, ctx;
            // user currently drawing (mouse is down and inside the canvas)
            var drawing = false;
            var hasDrawn = false;
            // current mouse position
            var currX = 0,
                currY = 0;
            // drawing colour and line width
            var drawColour = "black",
                lineWidth = 15;

            var drawPoints = [];
            
            function init() {
                // initialise canvas
                canvas = document.getElementById('digit-canvas');
                ctx = canvas.getContext("2d");
                ctx.fillStyle = drawColour;
                ctx.strokeStyle = drawColour;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = "round";

                // register mouse event listeners
                canvas.addEventListener("mousedown", function (e) {
                    onMouseEvent("mousedown", e);
                });
                canvas.addEventListener("mouseup", function (e) {
                    onMouseEvent("mouseup", e);
                });
                canvas.addEventListener("mousemove", function (e) {
                    onMouseEvent("mousemove", e);
                });
                canvas.addEventListener("mouseout", function (e) {
                    onMouseEvent("mouseout", e);
                });
            }

            function onMouseEvent(action, e) {
                // update current mouse position based on event vars
                currX = e.clientX - canvas.getBoundingClientRect().left;
                currY = e.clientY - canvas.getBoundingClientRect().top;

                switch (action) {
                    case "mousedown":
                        // start drawing
                        if (!hasDrawn) {
                            drawPoints = [];
                        }
                        else {
                            drawPoints.push("up");
                        }

                        drawing = hasDrawn = true;
                        ctx.moveTo(currX, currY);
                        lineToPoint(currX, currY);

                        drawPoints.push([currX, currY]);
                        break;
                    case "mouseup":
                    case "mouseout":
                        if (drawing) {
                            drawing = false;

                            autoResizeLineWidth();

                            // automatically classify canvas on mouse out/up
                            classify();
                        }
                        break;
                    case "mousemove":
                        if (drawing) {
                            // draw a line from where the mouse was to where it is now
                            lineToPoint(currX, currY);

                            drawPoints.push([currX, currY]);
                        }
                        break;
                }
            }

            function lineToPoint(x, y) {
                // connect a rounded line between where the mouse was and where the mouse currently is
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            }

            function reset() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // clear classification
                $("#classification").text("");
                $("#classify-time").text("");

                drawing = hasDrawn = false;
            }

            function recreateDrawing() {
                if (drawPoints.length == 0) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.moveTo(drawPoints[0][0], drawPoints[0][1]);

                for (var i = 0; i < drawPoints.length; i++) {
                    var drawPoint = drawPoints[i];
                    if (drawPoint == "up") {
                        i++;
                        ctx.moveTo(drawPoints[i][0], drawPoints[i][1]);
                    }
                    else {
                        lineToPoint(drawPoint[0], drawPoint[1]);
                    }
                }
            }

            function autoResizeLineWidth() {
                var canvasSize = 200;

                var left = canvasSize;
                var right = 0;
                var top = canvasSize;
                var bottom = 0;

                var rawCanvasData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                for (var i = 3; i < rawCanvasData.length; i += 4) {
                    if (rawCanvasData[i] > 0) {
                        var index = (i - 3) / 4;
                        var x = index % canvasSize;
                        var y = index / canvasSize;

                        left = Math.min(x, left);
                        right = Math.max(x, right);
                        top = Math.min(y, top);
                        bottom = Math.max(y, bottom);
                    }
                }

                var lineWidthFraction = 0.13;
                var newLineWith = ((right - left) * lineWidthFraction + (bottom - top) * lineWidthFraction) / 2;

                ctx.lineWidth = newLineWith;
                recreateDrawing();
            }

            // AJAX stuff
            // https://stackoverflow.com/a/35203184
            function classify() {
                var classifyStart = new Date().getTime();

                // load canvas data
                var rawCanvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var pixelArr = rawCanvasData.data;

                // encode pixel data using run-length encoding
                var runLengthEncoded = toRunLengthEncoding(pixelArr);

                // pass the data through another encoding, squashing each pair of
                // two characters into a single byte (since the array as a string only
                // has the values 0-9 and commas)
                var byteBufferEncoded = toNumberArrayEncoding(runLengthEncoded);

                // finally, encode the byte array as a Base64 string
                var base64Encoded = base64ArrayBuffer(byteBufferEncoded);

                // put together an object representing the encoded canvas data
                var encodedCanvas = {
                    // assuming the canvas dimensions will always be square
                    size: rawCanvasData.width,
                    pixelData: base64Encoded
                }

                // make an AJAX POST request, sending up the canvas data
                // the resulting classification will be displayed to the user as text
                $.post("/classify", encodedCanvas).done(function(result) {
                    var timeTaken = new Date().getTime() - classifyStart;

                    $("#classification").text(result);
                    $("#classify-time").text("Classified in " + timeTaken + " ms.");
                });
            }

            function toRunLengthEncoding(pixelArr) {
                // compress pixel data (taking advantage of it only having two values, black or transparent)
                // ie. instead of having [0, 0, 0, 0, 1, 1, 0, 0, 0], use the form [4, 2, 3]
                // as in: 4 transparent pixels followed by 2 black pixels followed by 3 white pixels
                // more info on the run-length encoding: https://en.wikipedia.org/wiki/Run-length_encoding

                var pixelArrCounts = []
                var onBlack = false;
                if (pixelArr[3] > 0) {
                    // starting on a transparent pixel
                    // (starting with "0 transparent pixels" just flips to black)
                    pixelArrCounts.push(0)
                    onBlack = true;
                }

                // count of black/transparent pixels in a row
                var count = 0;
                // canvas data has 4 components (RGBA) per pixel, so take steps of 4
                // to read only alpha values (check: transparent or not transparent pixel)
                for (var i = 3; i < pixelArr.length; i += 4) {
                    count++;

                    if ((pixelArr[i] > 0) != onBlack) {
                        // change in pixel colour from the prevoius one, record count and flip to white/black
                        pixelArrCounts.push(count);
                        onBlack = !onBlack;
                        count = 0;
                    }
                }

                if(count > 0) {
                    // still pixel counts to be recorded after loop
                    pixelArrCounts.push(count);
                }

                return pixelArrCounts;
            }

            function toNumberArrayEncoding(numbersArr) {
                // converts an array of numbers into an encoding of bytes, where each byte
                // is two characters of the array as a string
                // (4 bits needed to represent the numbers 0-9 or a comma)

                // create number array as string
                var jsonArr = JSON.stringify(numbersArr);
                // get half length (ignoring the brackets at either side)
                // this is how many bytes we'll need to encode the  number array
                var len = (jsonArr.length - 2) / 2;
                if (jsonArr.length % 2 == 1) {
                    // odd number of characters, need the extra byte
                    // (since integer division is floored)
                    len += 2;
                }

                // create byte buffer
                var buffer = new Uint8Array(len);
                var bufferCounter = 0;

                // ignoring the brackets on either side of the string
                for (var i = 1; i < jsonArr.length - 1; i += 2) {
                    var nextByte = 0;

                    // "," can just encode to 0 so we only have to change the byte value
                    // if it's a number being encoded
                    if (jsonArr.charAt(i) != ",") {
                        // encode the number in the byte's leftmost 4 bits
                        // (adding 1 since the comma's encoded value is already 0)
                        nextByte = (jsonArr.charCodeAt(i) - 48 + 1) << 4;
                    }

                    if (i == jsonArr.length - 2) {
                        // last character, must pad right bits with a comma and add in
                        // two redundant zeroes as the next byte
                        buffer[bufferCounter] = nextByte;
                        buffer[bufferCounter + 1] = (1 << 4) | 1;
                        break;
                    }
                    else if (jsonArr.charAt(i + 1) != ",") {
                        // use a bitwise OR to add this number's encoding to the
                        // rightmost 4 bits of the byte
                        nextByte = nextByte | (jsonArr.charCodeAt(i + 1) - 48 + 1);
                    }

                    buffer[bufferCounter++] = nextByte;
                }

                return buffer;
            }

            // taken from https://gist.github.com/jonleighton/958841
            // converts an ArrayBuffer of bytes into Base64
            function base64ArrayBuffer(arrayBuffer) {
                var base64    = ''
                var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

                // may as well not create a new buffer for this, since I don't need the buffer afterwards
                // var bytes         = new Uint8Array(arrayBuffer)
                var bytes         = arrayBuffer
                var byteLength    = bytes.byteLength
                var byteRemainder = byteLength % 3
                var mainLength    = byteLength - byteRemainder

                var a, b, c, d
                var chunk

                // Main loop deals with bytes in chunks of 3
                for (var i = 0; i < mainLength; i = i + 3) {
                    // Combine the three bytes into a single integer
                    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

                    // Use bitmasks to extract 6-bit segments from the triplet
                    a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
                    b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
                    c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
                    d = chunk & 63               // 63       = 2^6 - 1

                    // Convert the raw binary segments to the appropriate ASCII encoding
                    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
                }

                // Deal with the remaining bytes and padding
                if (byteRemainder == 1) {
                    chunk = bytes[mainLength]

                    a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

                    // Set the 4 least significant bits to zero
                    b = (chunk & 3)   << 4 // 3   = 2^2 - 1

                    base64 += encodings[a] + encodings[b] + '=='
                } else if (byteRemainder == 2) {
                    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

                    a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
                    b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

                    // Set the 2 least significant bits to zero
                    c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

                    base64 += encodings[a] + encodings[b] + encodings[c] + '='
                }
                
                return base64
                }
        </script>

        <!-- from bootstrap starter template -->
        <!-- (jquery slim swapped for full library) -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    </body>
</html>