<!doctype html>

<html lang="en">
    <head>
        <!-- from bootstrap starter template -->
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <!-- custom stylesheet on top of bootstrap -->
        <link rel="stylesheet" href="static/style.css">

        <title>Digit Classifier</title>
    </head>

    <body onload="init()">
        <div class="container mt-3">
            <div class="row">
                <div class="col-md-6 mx-auto">
                    <h2 class="text-center">Digit classifier</h2>
                </div>
            </div>

            <div class="row">
                <div class="col-md-6 mx-auto">
                    <h4 class="text-center">Draw a digit below to see how the neural network classifies it</h4>
                </div>
            </div>

            <div class="row">
                <div class="col-md-6 mx-auto">
                    <canvas id="digit-canvas" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="row">
                <div class="col-md-6 mx-auto mt-2">
                    <div class="text-center">
                        <button id="clear-button" type="button" onclick="reset()" class="btn btn-primary">Clear</button>
                    </div>
                </div>
            </div>

            <br />

            <div class="row">
                <div class="col-md-6 mx-auto text-center">
                    <h4>Classification:</h2>
                </div>
            </div>

            <div class="row">
                <div class="col-md-6 mx-auto text-center">
                    <h2 id="classification"></h2>
                </div>
            </div>

            <div class="row">
                <div class="col-md-6 mx-auto text-center">
                    <h5 id="classify-time" class="font-italic"></h2>
                </div>
            </div>
        </div>

        <script>
            // adapted from https://stackoverflow.com/a/8398189
            var canvas, ctx;
            // user currently drawing (mouse is down and inside the canvas)
            var drawing = false;
            var hasDrawn = false;
            // current mouse position
            var currX = 0,
                currY = 0;
            // drawing colour and line width
            var drawColour = "black",
                lineWidth = 15;
            var drawPoints = [];
            var isMobile = false;
            
            function init() {
                // from https://stackoverflow.com/a/3540295
                // detect if this is a touch device or not
                if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
                    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
                    isMobile = true;
                }
                
                // initialise canvas
                canvas = document.getElementById('digit-canvas');
                ctx = canvas.getContext("2d");
                ctx.fillStyle = drawColour;
                ctx.strokeStyle = drawColour;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = "round";

                // register mouse event listeners
                canvas.addEventListener("mousedown", function (e) {
                    onMouseEvent("mousedown", e);
                });
                canvas.addEventListener("mouseup", function (e) {
                    onMouseEvent("mouseup", e);
                });
                canvas.addEventListener("mousemove", function (e) {
                    onMouseEvent("mousemove", e);
                });
                canvas.addEventListener("mouseout", function (e) {
                    onMouseEvent("mouseout", e);
                });

                // register event listeners for touch devices
                canvas.addEventListener("touchstart", function (e) {
                    onMouseEvent("touchstart", e);
                });
                canvas.addEventListener("touchend", function (e) {
                    onMouseEvent("touchend", e);
                });
                canvas.addEventListener("touchmove", function (e) {
                    onMouseEvent("touchmove", e);
                });
                canvas.addEventListener("touchcancel", function (e) {
                    onMouseEvent("touchcancel", e);
                });
            }

            function onMouseEvent(action, e) {
                if (isMobile) {
                    // prevent back/forward swipes etc. in the browser on mobile devices
                    e.preventDefault();
                }

                switch (action) {
                    case "mousedown":
                    case "touchstart":
                        updateCursorPos(e)

                        // start drawing
                        if (!hasDrawn) {
                            // start a new list of drawing points
                            drawPoints = [];
                        }
                        else {
                            // user is continuing on their drawing, make sure this point
                            // doesn't get drawn connected to the previous point
                            drawPoints.push("up");
                        }
                        drawing = hasDrawn = true;
                        ctx.moveTo(currX, currY);
                        lineToPoint(currX, currY);

                        drawPoints.push([currX, currY]);
                        break;
                    case "mouseup":
                    case "touchend":
                    case "mouseout":
                        if (drawing) {
                            drawing = false;

                            // resize line width based on how big the digit the user drew was
                            autoResizeLineWidth();

                            // automatically classify canvas on mouse out/up
                            classify();
                        }
                        break;
                    case "mousemove":
                    case "touchmove":
                        if (drawing) {
                            updateCursorPos(e)
                            // draw a line from where the mouse was to where it is now
                            lineToPoint(currX, currY);

                            drawPoints.push([currX, currY]);
                        }
                        break;
                }
            }

            function updateCursorPos(e) {
                // update current mouse position based on event vars
                if (isMobile) {
                    currX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
                    currY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
                }
                else {
                    currX = e.clientX - canvas.getBoundingClientRect().left;
                    currY = e.clientY - canvas.getBoundingClientRect().top;
                }
            }

            function lineToPoint(x, y) {
                // connect a rounded line between where the mouse was and where the mouse currently is
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            }

            function reset() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // clear classification
                $("#classification").text("");
                $("#classify-time").text("");

                drawing = hasDrawn = false;
            }

            function recreateDrawing() {
                // redraw user draw digit on canvas from list of recorded points

                if (drawPoints.length == 0) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.moveTo(drawPoints[0][0], drawPoints[0][1]);

                for (var i = 0; i < drawPoints.length; i++) {
                    var drawPoint = drawPoints[i];
                    if (drawPoint == "up") {
                        // user stopped drawing this line before continuing drawing, move to next point
                        i++;
                        ctx.moveTo(drawPoints[i][0], drawPoints[i][1]);
                    }
                    else {
                        lineToPoint(drawPoint[0], drawPoint[1]);
                    }
                }
            }

            function autoResizeLineWidth() {
                // automatically resize line width based on the size of the image the user drew
                var canvasSize = 200;

                // find the bounding box around what the user drew
                var left = canvasSize;
                var right = 0;
                var top = canvasSize;
                var bottom = 0;

                var rawCanvasData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                for (var i = 3; i < rawCanvasData.length; i += 4) {
                    if (rawCanvasData[i] > 0) {
                        var index = (i - 3) / 4;
                        var x = index % canvasSize;
                        var y = index / canvasSize;

                        left = Math.min(x, left);
                        right = Math.max(x, right);
                        top = Math.min(y, top);
                        bottom = Math.max(y, bottom);
                    }
                }

                // compute new line width
                // (0.11 * width or height, whichever was longer, with a minimum of 1 and maximum of 15)
                var lineWidthFraction = 0.11;
                var newLineWith = Math.ceil(Math.max(right - left, bottom - top) * lineWidthFraction);
                newLineWidth = Math.min(newLineWith, 15);
                newLineWidth = Math.max(newLineWith, 1);

                ctx.lineWidth = newLineWith;

                // redraw digit with new line width
                recreateDrawing();
            }

            // AJAX stuff
            // https://stackoverflow.com/a/35203184
            function classify() {
                var classifyStart = new Date().getTime();

                // load canvas data
                var rawCanvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var pixelArr = rawCanvasData.data;

                // encode pixel data using run-length encoding
                var runLengthEncoded = toRunLengthEncoding(pixelArr);

                // pass the data through another encoding, squashing each pair of
                // two characters into a single byte (since the array as a string only
                // has the values 0-9 and commas)
                var byteBufferEncoded = toNumberArrayEncoding(runLengthEncoded);

                // finally, encode the byte array as a Base64 string
                var base64Encoded = base64ArrayBuffer(byteBufferEncoded);

                // put together an object representing the encoded canvas data
                var encodedCanvas = {
                    // assuming the canvas dimensions will always be square
                    size: rawCanvasData.width,
                    pixelData: base64Encoded
                }

                // make an AJAX POST request, sending up the canvas data
                // the resulting classification will be displayed to the user as text
                $.post("/classify", encodedCanvas).done(function(result) {
                    var timeTaken = new Date().getTime() - classifyStart;

                    $("#classification").text(result);
                    $("#classify-time").text("Classified in " + timeTaken + " ms.");
                });
            }

            function toRunLengthEncoding(pixelArr) {
                // compress pixel data (taking advantage of it only having two values, black or transparent)
                // ie. instead of having [0, 0, 0, 0, 1, 1, 0, 0, 0], use the form [4, 2, 3]
                // as in: 4 transparent pixels followed by 2 black pixels followed by 3 white pixels
                // more info on the run-length encoding: https://en.wikipedia.org/wiki/Run-length_encoding

                var pixelArrCounts = []
                var onBlack = false;
                if (pixelArr[3] > 0) {
                    // starting on a transparent pixel
                    // (starting with "0 transparent pixels" just flips to black)
                    pixelArrCounts.push(0)
                    onBlack = true;
                }

                // count of black/transparent pixels in a row
                var count = 0;
                // canvas data has 4 components (RGBA) per pixel, so take steps of 4
                // to read only alpha values (check: transparent or not transparent pixel)
                for (var i = 3; i < pixelArr.length; i += 4) {
                    count++;

                    if ((pixelArr[i] > 0) != onBlack) {
                        // change in pixel colour from the prevoius one, record count and flip to white/black
                        pixelArrCounts.push(count);
                        onBlack = !onBlack;
                        count = 0;
                    }
                }

                if(count > 0) {
                    // still pixel counts to be recorded after loop
                    pixelArrCounts.push(count);
                }

                return pixelArrCounts;
            }

            function toNumberArrayEncoding(numbersArr) {
                // converts an array of numbers into an encoding of bytes, where each byte
                // is two characters of the array as a string
                // (4 bits needed to represent the numbers 0-9 or a comma)

                // create number array as string
                var jsonArr = JSON.stringify(numbersArr);
                // get half length (ignoring the brackets at either side)
                // this is how many bytes we'll need to encode the  number array
                var len = (jsonArr.length - 2) / 2;
                if (jsonArr.length % 2 == 1) {
                    // odd number of characters, need the extra byte
                    // (since integer division is floored)
                    len += 2;
                }

                // create byte buffer
                var buffer = new Uint8Array(len);
                var bufferCounter = 0;

                // ignoring the brackets on either side of the string
                for (var i = 1; i < jsonArr.length - 1; i += 2) {
                    var nextByte = 0;

                    // "," can just encode to 0 so we only have to change the byte value
                    // if it's a number being encoded
                    if (jsonArr.charAt(i) != ",") {
                        // encode the number in the byte's leftmost 4 bits
                        // (adding 1 since the comma's encoded value is already 0)
                        nextByte = (jsonArr.charCodeAt(i) - 48 + 1) << 4;
                    }

                    if (i == jsonArr.length - 2) {
                        // last character, must pad right bits with a comma and add in
                        // two redundant zeroes as the next byte
                        buffer[bufferCounter] = nextByte;
                        buffer[bufferCounter + 1] = (1 << 4) | 1;
                        break;
                    }
                    else if (jsonArr.charAt(i + 1) != ",") {
                        // use a bitwise OR to add this number's encoding to the
                        // rightmost 4 bits of the byte
                        nextByte = nextByte | (jsonArr.charCodeAt(i + 1) - 48 + 1);
                    }

                    buffer[bufferCounter++] = nextByte;
                }

                return buffer;
            }

            // taken from https://gist.github.com/jonleighton/958841
            // converts an ArrayBuffer of bytes into Base64
            function base64ArrayBuffer(arrayBuffer) {
                var base64    = ''
                var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

                // may as well not create a new buffer for this, since I don't need the buffer afterwards
                // var bytes         = new Uint8Array(arrayBuffer)
                var bytes         = arrayBuffer
                var byteLength    = bytes.byteLength
                var byteRemainder = byteLength % 3
                var mainLength    = byteLength - byteRemainder

                var a, b, c, d
                var chunk

                // Main loop deals with bytes in chunks of 3
                for (var i = 0; i < mainLength; i = i + 3) {
                    // Combine the three bytes into a single integer
                    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

                    // Use bitmasks to extract 6-bit segments from the triplet
                    a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
                    b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
                    c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
                    d = chunk & 63               // 63       = 2^6 - 1

                    // Convert the raw binary segments to the appropriate ASCII encoding
                    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
                }

                // Deal with the remaining bytes and padding
                if (byteRemainder == 1) {
                    chunk = bytes[mainLength]

                    a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

                    // Set the 4 least significant bits to zero
                    b = (chunk & 3)   << 4 // 3   = 2^2 - 1

                    base64 += encodings[a] + encodings[b] + '=='
                } else if (byteRemainder == 2) {
                    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

                    a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
                    b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

                    // Set the 2 least significant bits to zero
                    c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

                    base64 += encodings[a] + encodings[b] + encodings[c] + '='
                }
                
                return base64
                }
        </script>

        <!-- from bootstrap starter template -->
        <!-- (jquery slim swapped for full library) -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    </body>
</html>